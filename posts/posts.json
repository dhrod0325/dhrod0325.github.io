[{"html":"<h1><a id=\"core-js\" class=\"anchor\" href=\"#core-js\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CORE JS</h1>\n<h2><a id=\"undefined와-null의-차이\" class=\"anchor\" href=\"#undefined와-null의-차이\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>undefined와 null의 차이</h2>\n<p>undefined는 변수를 선언하고 값을 할당하지 않은 상태이다.</p>\n<p>null은 변수를 선언하고 빈 값을 할당한 상태이다.</p>\n<p>undefined는 전역 객체의 속성 중 하나이고 전역 스코프에서 변수이기도 하다.</p>\n<p>undefined는 예약어가 아니기 때문에 변수 이름으로 사용할 수 있다.</p>\n<p>아래의 경우 변수가 undefined를 반환한다.</p>\n<ul>\n<li>\n<p>값을 할당하지 않은 변수</p>\n</li>\n<li>\n<p>메서드와 선언에서 변수가 할당받지 않은 경우</p>\n</li>\n<li>\n<p>함수가 값을 return 하지 않았을 때</p>\n</li>\n<li>\n<p>null은 어떤 값이 의도적으로 비어 있음을 말한다. null은 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다.</p>\n</li>\n<li>\n<p>null은 undefined 처럼 전역 객체의 속성 중 하나가 아니라 리터럴 값이다.</p>\n</li>\n<li>\n<p>typeof null 은 object를 반환 하지만 하위 호환성을 유지하기위한 오류를 남겨둔 것이다. null은 object가 아니다.</p>\n</li>\n</ul>\n<h2><a id=\"형-변환\" class=\"anchor\" href=\"#형-변환\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>형 변환</h2>\n<p>숫자형으로 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.</p>\n<pre><code class=\"language-jsx\">alert('6' / '2'); // 3을 반환한다. 자동 형변환 됨\nalert('hi' / 2); // Nan을 반환한다.\n</code></pre>\n<h2><a id=\"연산자의-우선순위\" class=\"anchor\" href=\"#연산자의-우선순위\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연산자의 우선순위</h2>\n<p>17 단항 덧셈 +</p>\n<p>17 단항 부정 -</p>\n<p>16 지수 **</p>\n<p>15 곱셈 *</p>\n<p>15 나눗셈 /</p>\n<p>13 덧셈 +</p>\n<p>13 뺄셈 -</p>\n<p>3   할당 =</p>\n<h2><a id=\"복합연산\" class=\"anchor\" href=\"#복합연산\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>복합연산</h2>\n<p>복합연산은 오른쪽에서 왼쪽으로 진행된다.</p>\n<pre><code class=\"language-jsx\">let a,b,c;\n\na = b = c = 2 + 2;\n</code></pre>\n<h2><a id=\"쉼표-연산자\" class=\"anchor\" href=\"#쉼표-연산자\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>쉼표 연산자</h2>\n<p>, 는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다.</p>\n<h2><a id=\"문자열-비교-알고리즘\" class=\"anchor\" href=\"#문자열-비교-알고리즘\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열 비교 알고리즘</h2>\n<ol>\n<li>유니코드 순서로 비교한다 (유니코드 값으로 비교하면 a가 A보다 크다)</li>\n<li>글자를 첫 글자부터 하나씩 비교해 나가면서 크기를 비교한다</li>\n</ol>\n<ul>\n<li>비교하려는 자료형이 다르면 숫자로 변환하여 비교한다</li>\n</ul>\n<h2><a id=\"null과-0의-비교\" class=\"anchor\" href=\"#null과-0의-비교\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null과 0의 비교</h2>\n<pre><code class=\"language-jsx\">alert( null &gt; 0 );  // (1) false\nalert( null == 0 ); // (2) false\nalert( null &gt;= 0 ); // (3) true\n</code></pre>\n<ul>\n<li>==은 피연산자가 null일때 형변환을 하지 않는다.</li>\n<li>≥ ≤ &lt; &gt; 는 형변환을 하고 비교를 진행한다.</li>\n</ul>\n<pre><code class=\"language-jsx\">console.log( undefined &gt;= 0 ); //false\n</code></pre>\n<ul>\n<li>undefined는 Nan으로 형변환 된다.</li>\n</ul>\n<h3><a id=\"위-상황을-피하는-방법\" class=\"anchor\" href=\"#위-상황을-피하는-방법\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위 상황을 피하는 방법</h3>\n<ul>\n<li>===을 제외한 비교 연산자의 피 연산자에 undefined나 null이 오지 않도록 주의한다.</li>\n<li>undefined나 null이 될 가능성이 있는 변수가 &lt;,&gt;,≤,≥의 피 연산자가 되지 않도록 주의한다.</li>\n</ul>\n<h2><a id=\"or의-반환-값\" class=\"anchor\" href=\"#or의-반환-값\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OR의 반환 값</h2>\n<p>OR가 참일 때 의 반환 값은 boolean이 아니라 결과 값 그 자체</p>\n<pre><code class=\"language-jsx\">const a = false;\nconst b = 10;\n\nconst c = a || b; // c = 10\n</code></pre>\n<h2><a id=\"and와-or의-우선순위\" class=\"anchor\" href=\"#and와-or의-우선순위\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AND와 OR의 우선순위</h2>\n<ul>\n<li>AND가 OR 보다 우선순위가 더 높다\n<ul>\n<li>a &amp;&amp; b || c &amp;&amp; d는 (a &amp;&amp; b) || (c &amp;&amp; d)와 동일하게 동작</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-jsx\">alert( null || 2 &amp;&amp; 3 || 4 );\n\n// 3이 출력된다 &amp;&amp;가 || 보다 우선순위가 높다 \n// 2도 참이고 3도 참이기 때문에 2 &amp;&amp; 3 은 3을 반환한다.\n\nif(-1) {\n    console.log(1); // 실행된다.\n}\n</code></pre>\n<h2><a id=\"nullish-병합-연산자\" class=\"anchor\" href=\"#nullish-병합-연산자\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>nullish 병합 연산자</h2>\n<p>??는 =와 ? 보다는 먼저, 대부분의 연산자보다는 나중에 평가</p>\n<pre><code class=\"language-jsx\">a !== null &amp;&amp; a !== undefined;\na ?? b;\n\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\n</code></pre>\n<h2><a id=\"루프\" class=\"anchor\" href=\"#루프\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>루프</h2>\n<p>? 연산자 우측에 루프문 continue를 사용 할 수 없다</p>\n<pre><code>(i &gt; 5) ? alert(i) : continue; // 여기에 continue를 사용하면 안 됩니다.\n</code></pre>\n<h2><a id=\"바벨babel\" class=\"anchor\" href=\"#바벨babel\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>바벨(Babel)</h2>\n<ul>\n<li>코드를 재작성해주는 트랜스파일러 프로그램</li>\n<li>실행하면 기존 코드가 구 표준을 준수하는 코드로 변경됨</li>\n<li>웹팩과 함께 사용하면 코드가 변경될 때 자동으로 트랜스파일러를 동작시킴</li>\n</ul>\n<h2><a id=\"계산된-프로퍼티\" class=\"anchor\" href=\"#계산된-프로퍼티\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>계산된 프로퍼티</h2>\n<pre><code class=\"language-jsx\">const a = 'hello';\n\nconst o = {\n\t[a] : 'world'\n}\n</code></pre>\n<h2><a id=\"객체의-정렬\" class=\"anchor\" href=\"#객체의-정렬\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체의 정렬</h2>\n<ul>\n<li>키 값이 숫자라면 키 순서로 자동 정렬 된다.</li>\n<li>‘1’ 은 숫자로 자동 형 변환된다.</li>\n<li>문자는 추가되는 순서로 들어간다.</li>\n</ul>\n<pre><code class=\"language-jsx\">const o2 = {\n    45:'test45',\n    1:'test1'\n};\n\n//결과 : { '1': 'test1', '45': 'test45' }\n</code></pre>\n<h2><a id=\"symbol\" class=\"anchor\" href=\"#symbol\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol</h2>\n<p>Symbol은 유일한 식별자를 만들고 싶을 때 사용함</p>\n<h3><a id=\"특징\" class=\"anchor\" href=\"#특징\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>특징</h3>\n<ul>\n<li>for in 으로 접근 할 수 없음</li>\n<li>Object.properties로 출력 되지 않음</li>\n<li>alert(Symbol(’test’))로 출력 되지 않음(문자열로 변환 안됨)</li>\n</ul>\n<h3><a id=\"전역심볼\" class=\"anchor\" href=\"#전역심볼\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전역심볼</h3>\n<ul>\n<li>Symbol.for(”id”) 없으면 만들어 쓰고 있으면 가저옴</li>\n</ul>\n<h2><a id=\"\" class=\"anchor\" href=\"#\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>..</h2>\n<p>.. 은 숫자에 래퍼 메소드를 사용할때 사용됨</p>\n<pre><code class=\"language-jsx\">123.toString() // error .을 소수점으로 판단함\n123..toString() // ok\n</code></pre>\n<h2><a id=\"isnan-과-isfinite\" class=\"anchor\" href=\"#isnan-과-isfinite\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>isNan 과 isFinite</h2>\n<ul>\n<li>Nan은 자기 자신을 포함하여 그 어떤 값과도 같지 않다</li>\n<li>isFinite는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.</li>\n</ul>\n<pre><code class=\"language-jsx\">alert( isNaN(NaN) ); // true\nalert( isNaN(&quot;str&quot;) ); // true\n\nalert( NaN === NaN ); // false\n//자기 자신을 포함하여 그 어떤 값과도 같지 않다\nalert( Object.is(NaN,NaN )); // true\n</code></pre>\n<h2><a id=\"숫자-형변환-차이점--parseint-number\" class=\"anchor\" href=\"#숫자-형변환-차이점--parseint-number\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>숫자 형변환 차이점 (+, parseInt, Number)</h2>\n<pre><code class=\"language-jsx\">alert( +&quot;100px&quot; ); // NaN\n\nalert( parseInt('100px') ); // 100\nalert( parseFloat('12.5em') ); // 12.5\n\nalert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.\nalert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.\n</code></pre>\n<h2><a id=\"태그드리터럴\" class=\"anchor\" href=\"#태그드리터럴\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>태그드리터럴</h2>\n<pre><code class=\"language-jsx\">function myString(str,name,age){\n    return `${str.join('')} ${name} ${age}`;\n}\n\nconst name = '홍길동';\nconst age = 18;\n\nconst a = myString`hello world ${name} ${age}`;\n\nconsole.log(a); // hello world  홍길동 18\n</code></pre>\n<h2><a id=\"forin\" class=\"anchor\" href=\"#forin\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for..in</h2>\n<ul>\n<li>모든 프로퍼티를 순회하기 때문에 사용을 지양한다.</li>\n<li>객체와 함께 사용할 때 최적화 되어있다. 배열을 순회할 때 성능 저하가 있으므로 배열에서 사용을 지양한다.</li>\n</ul>\n<h2><a id=\"배열\" class=\"anchor\" href=\"#배열\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열</h2>\n<h3><a id=\"삭제\" class=\"anchor\" href=\"#삭제\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>삭제</h3>\n<ul>\n<li>\n<p>delete로 삭제했을때의 문제점</p>\n<pre><code class=\"language-jsx\">let arr = [&quot;I&quot;, &quot;go&quot;, &quot;home&quot;];\n\ndelete arr[1]; // &quot;go&quot;를 삭제합니다.\n\nalert( arr[1] ); // undefined\n\n// delete를 써서 요소를 지우고 난 후 배열 --&gt; arr = [&quot;I&quot;,  , &quot;home&quot;];\nalert( arr.length ); // 3\n\n//값은 삭제되지만 요소가 삭제되지 않는다.\n</code></pre>\n</li>\n</ul>\n<h3><a id=\"교체\" class=\"anchor\" href=\"#교체\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>교체</h3>\n<pre><code class=\"language-jsx\">let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;, &quot;right&quot;, &quot;now&quot;];\n\n// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체합니다.\narr.splice(0, 3, &quot;Let's&quot;, &quot;dance&quot;);\n\nalert( arr ) // now [&quot;Let's&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]\n</code></pre>\n<h3><a id=\"추가\" class=\"anchor\" href=\"#추가\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가</h3>\n<pre><code class=\"language-jsx\">let arr = [&quot;I&quot;, &quot;study&quot;, &quot;JavaScript&quot;];\n\n// 인덱스 2부터\n// 0개의 요소를 삭제합니다.\n// 그 후, &quot;complex&quot;와 &quot;language&quot;를 추가합니다.\narr.splice(2, 0, &quot;complex&quot;, &quot;language&quot;);\n\nalert( arr ); // &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;\n</code></pre>\n<h3><a id=\"정렬\" class=\"anchor\" href=\"#정렬\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬</h3>\n<ul>\n<li>\n<p>sort는 문자열로 취급되어 정렬된다.</p>\n</li>\n<li>\n<p>sort는 최적화된 퀵 정렬을 이용한다.</p>\n</li>\n<li>\n<p>숫자로 취급하기 위해서는 다음과 같이 정렬 함수를 넘겨준다.</p>\n<pre><code class=\"language-jsx\">const arr = [1,2,3,4,15];\narr.sort((a,b)=&gt;a-b); // 오름차순\narr.sort((a,b)=&gt;a+b); // 내림차순\n</code></pre>\n</li>\n<li>\n<p>sort는 배열 자체를 변경하므로 다음과 같이 방어적 복사를 진행하는 것이 좋다</p>\n<pre><code class=\"language-jsx\">const arr = [1,2,15,4,6];\nconst sorted = [...arr].sort((a,b)=&gt;a-b);\n</code></pre>\n</li>\n</ul>\n<h2><a id=\"iterable-객체\" class=\"anchor\" href=\"#iterable-객체\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>iterable 객체</h2>\n<ul>\n<li>iterable은 메서드 Symbol.iterator가 구현된 객체이다.</li>\n<li>array-like는 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체이다.</li>\n<li>iterable과 array-like는 다르다.</li>\n</ul>\n<ol>\n<li>for..of가 시작되자마자 for..of는 Symbol.iterator를 호출합니다(Symbol.iterator가 없으면 에러가 발생합니다). Symbol.iterator는 반드시 이터레이터(iterator, 메서드 next가 있는 객체) 를 반환해야 합니다.</li>\n<li>이후 for..of는 반환된 객체(이터레이터)만을 대상으로 동작합니다.</li>\n<li>for..of에 다음 값이 필요하면, for..of는 이터레이터의 next()메서드를 호출합니다.</li>\n<li>next()의 반환 값은 {done: Boolean, value: any}와 같은 형태이어야 합니다. done=true는 반복이 종료되었음을 의미합니다. done=false일땐 value에 다음 값이 저장됩니다.</li>\n</ol>\n<pre><code class=\"language-jsx\">console.log(&quot;test&quot;[Symbol.iterator]); //[Function: [Symbol.iterator]]\nconsole.log(([][Symbol.iterator])); //[Function: values]\n</code></pre>\n<h3><a id=\"직접-구현해보기\" class=\"anchor\" href=\"#직접-구현해보기\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>직접 구현해보기</h3>\n<pre><code class=\"language-jsx\">const Range = (from, to) =&gt; {\n    return {\n        [Symbol.iterator](){\n            this.current = from;\n            return this;\n        },\n\n        next(){\n            if(this.current &lt;= to){\n                return {done:false,value:this.current++};\n            }else{\n                return {done:true}\n            }\n        }\n    }\n};\n\nconsole.log(Range(1,10));\nconsole.log(Array.from(Range(1,10)));\n</code></pre>\n<h3><a id=\"문자열도-iterable이다\" class=\"anchor\" href=\"#문자열도-iterable이다\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열도 iterable이다</h3>\n<pre><code class=\"language-jsx\">Array.from(&quot;test&quot;); // ['t','e','s','t']\n</code></pre>\n<h2><a id=\"맵\" class=\"anchor\" href=\"#맵\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>맵</h2>\n<p>Object.entries() 객체를 맵으로 바꾸기</p>\n<pre><code class=\"language-jsx\">let obj = {\n  name: &quot;John&quot;,\n  age: 30\n};\n\nlet map = new Map(Object.entries(obj));\n\nalert( map.get('name') ); // John\n</code></pre>\n<h2><a id=\"위크-맵위크-셋\" class=\"anchor\" href=\"#위크-맵위크-셋\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>위크 맵,위크 셋</h2>\n<p>가비지컬렉션이 메모리에서 자동으로 삭제 될 수 있도록 도와준다.</p>\n<pre><code class=\"language-jsx\">let john = { name: &quot;John&quot; };\n\nlet weakMap = new WeakMap();\nweakMap.set(john, &quot;...&quot;);\n\njohn = null; // 참조를 덮어씀\n\n// john을 나타내는 객체는 이제 메모리에서 지워집니다!\n</code></pre>\n<h2><a id=\"구조분해할당\" class=\"anchor\" href=\"#구조분해할당\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>구조분해할당</h2>\n<ul>\n<li>\n<p>할당 연산자 우측엔 모든 이터러블이 올 수 있다.</p>\n</li>\n<li>\n<p>할당 연산자의 좌측에는 어떤 것이든 올 수 있다</p>\n<pre><code class=\"language-jsx\">let user = {};\n[user.name, user.surname] = &quot;Bora Lee&quot;.split(' ');\n\nalert(user.name); // Bora\n</code></pre>\n</li>\n</ul>\n<h2><a id=\"json\" class=\"anchor\" href=\"#json\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSON</h2>\n<p>직렬화</p>\n<pre><code class=\"language-jsx\">const User = (name,age,date = new Date()) =&gt; {\n    return {\n        toJSON : () =&gt; {\n            return {name,age,date}\n        }\n    }\n}\n\nconst user = User('홍길동',15);\n\nconst jsonString = JSON.stringify(user);\n\nconst toObject = JSON.parse(jsonString,(key,value)=&gt;{\n    if (key === 'date'){\n        return new Date(value);\n    }\n\n    return value;\n});\n\nconsole.log(toObject);\n</code></pre>\n<ul>\n<li>순환참조가 발생하면 JSON.parse를 사용할 수 없다. revival 함수에서 순환참조가 발생하는 property는 건너 뛰어야 한다.,</li>\n</ul>\n<h2><a id=\"클로저\" class=\"anchor\" href=\"#클로저\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클로저</h2>\n<h3><a id=\"lexical-environment\" class=\"anchor\" href=\"#lexical-environment\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lexical Environment</h3>\n<p>실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경(Lexcial Environment)라 불리는 내부 숨김 연관 객체를 갖는다.</p>\n<p>렉시컬 환경 객체는 두 부분으로 구성된다. 렉시컬 횐경은 이론상의 객체이다.</p>\n<ul>\n<li>환경 레코드 (Environment Record) : 모든 지역 변수를 프로퍼티로 저장하고 있느 ㄴ객체.</li>\n<li>외부 렉시컬 환경(Outer) : 외부 코드와 연관된다.</li>\n</ul>\n<h2><a id=\"렉시컬-등록-순서\" class=\"anchor\" href=\"#렉시컬-등록-순서\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>렉시컬 등록 순서</h2>\n<ol>\n<li>호이스팅한다</li>\n<li>렉시컬 환경에 등록한다. (이때 함수는 위로 올라가고 즉시 실행 가능해진다. let, const로 선언한 변수는 렉시컬 환경에 등록되지만 let이 실행되기 전까지 참조가 불가능하다)</li>\n<li>변수는 uninitialized로 올라가며 함수는 function으로 즉시 등록된다.</li>\n</ol>\n<h3><a id=\"변수의-렉시컬-환경\" class=\"anchor\" href=\"#변수의-렉시컬-환경\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수의 렉시컬 환경</h3>\n<pre><code class=\"language-jsx\">let test = 'hello';\n\n//이 경우에 렉시컬 환경이 하나만 존재한다. 전역 변수 이므로 outer는 null이다.\n</code></pre>\n<h3><a id=\"함수의-렉시컬-환경\" class=\"anchor\" href=\"#함수의-렉시컬-환경\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수의 렉시컬 환경</h3>\n<pre><code class=\"language-jsx\">say('hello');\n\nfunction say(name) {\n   console.log(`${name}`);\n}\n</code></pre>\n<p>함수는 렉시컬 환경에 등록되는 즉시 사용이 가능하다. 함수가 선언되기 전에 사용 가능한 것은 이러한 이유이다.</p>\n<h2><a id=\"비동기\" class=\"anchor\" href=\"#비동기\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기</h2>\n<pre><code class=\"language-jsx\">function block(time){\n    const endTime = Date.now() + time;\n\n    while(true){\n        const currentTime = Date.now();\n\n        if(currentTime &gt; endTime){\n            break;\n        }\n    }\n\n    console.log('end');\n}\n\nfunction hello(){\n    console.log('hello');\n}\n\nsetTimeout(hello,2500);\n\nblock(3000);\n</code></pre>\n<p>hello 는 100ms 가 지난 후 바로 호출되지 않으며 block 메소드가 종료되고 난 이후 호출된다.</p>\n<h2><a id=\"기명-함수-표현식\" class=\"anchor\" href=\"#기명-함수-표현식\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기명 함수 표현식</h2>\n<p>이름이 있는 함수 표현식</p>\n<pre><code class=\"language-jsx\">let sayHi = function func(who) {\n  if (who) {\n    alert(`Hello, ${who}`);\n  } else {\n    func(&quot;Guest&quot;); // func를 사용해서 자신을 호출합니다.\n  }\n};\n\nsayHi(); // Hello, Guest\n\n// 하지만 아래와 같이 func를 호출하는 건 불가능합니다.\nfunc(); // Error, func is not defined (기명 함수 표현식 밖에서는 그 이름에 접근할 수 없습니다.)\n</code></pre>\n<h2><a id=\"new-function\" class=\"anchor\" href=\"#new-function\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>new Function</h2>\n<ul>\n<li>eval을 사용하지 않고 문자열을 함수로 변경 할 수 있다.</li>\n</ul>\n<pre><code>let str = ... 서버에서 동적으로 전달받은 문자열(코드 형태) ...\n\nlet func = new Function(str);\nfunc();\n</code></pre>\n<ul>\n<li>new Function을 이용해 함수를 만들면 함수의 Environment 프로퍼티가 현재 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다.</li>\n</ul>\n<pre><code class=\"language-jsx\">function getFunc() {\n  let value = &quot;test&quot;;\n\n  let func = new Function('alert(value)');\n\n  return func;\n}\n\ngetFunc()(); // ReferenceError: value is not defined\n</code></pre>\n<h2><a id=\"settimeoutsetinterval\" class=\"anchor\" href=\"#settimeoutsetinterval\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>setTimeout,setInterval</h2>\n<h3><a id=\"가비지-컬렉션과-setintervalsettimeout\" class=\"anchor\" href=\"#가비지-컬렉션과-setintervalsettimeout\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>가비지 컬렉션과 setInterval·setTimeout</h3>\n<p>setInterval이나 setTimeout에 함수를 넘기면, 함수에 대한 내부 참조가 새롭게 만들어지고 이 참조 정보는 스케줄러에 저장됩니다. 따라서 해당 함수를 참조하는 것이 없어도 setInterval과 setTimeout에 넘긴 함수는 가비지 컬렉션의 대상이 되지 않습니다.</p>\n<pre><code class=\"language-jsx\">// 스케줄러가 함수를 호출할 때까지 함수는 메모리에 유지됩니다.\nsetTimeout(function() {...}, 100);\n//setInterval의 경우는, clearInterval이 호출되기 전까지 함수에 대한 참조가 메모리에 유지됩니다.\n</code></pre>\n<p>그런데 이런 동작 방식에는 부작용이 하나 있습니다.</p>\n<p>외부 렉시컬 환경을 참조하는 함수가 있다고 가정해 봅시다. 이 함수가 메모리에 남아있는 동안엔 외부 변수 역시 메모리에 남아있기 마련입니다. 그런데 이렇게 되면 실제 함수가 차지했어야 하는 공간보다 더 많은 메모리 공간이 사용됩니다.</p>\n<p>이런 부작용을 방지하고 싶다면 스케줄링할 필요가 없어진 함수는 아무리 작더라도 취소하도록 합시다.</p>\n<h3><a id=\"브라우저-환경에서-실제-대기-시간은-0이-아닙니다\" class=\"anchor\" href=\"#브라우저-환경에서-실제-대기-시간은-0이-아닙니다\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>브라우저 환경에서 실제 대기 시간은 0이 아닙니다.</h3>\n<p>브라우저는 HTML5 표준에서 정한 중첩 타이머 실행 간격 관련 제약을 준수합니다. 해당 표준엔 &quot;다섯 번째 중첩 타이머 이후엔 대기 시간을 최소 4밀리초 이상으로 강제해야 한다.&quot;라는 제약이 명시되어있습니다.</p>\n<p>지연 없이 중첩 setTimeout을 5회 이상 호출하거나 지연 없는 setInterval에서 호출이 5회 이상 이뤄지면, 4밀리초 이상의 지연 간격이 강제로 더해집니다. 이는 브라우저에만 적용되는 사항이며, 하위 호환성을 위해 유지되고 있습니다.</p>\n<p>스케줄링 메서드를 사용할 땐 명시한 지연 간격이 보장되지 않을 수도 있다는 점에 유의해야 합니다.</p>\n<p>아래와 같은 상황에서 브라우저 내 타이머가 느려지면 지연 간격이 보장되지 않습니다.</p>\n<ul>\n<li>CPU가 과부하 상태인 경우</li>\n<li>브라우저 탭이 백그라운드 모드인 경우</li>\n<li>노트북이 배터리에 의존해서 구동 중인 경우</li>\n</ul>\n<h2><a id=\"promise\" class=\"anchor\" href=\"#promise\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise</h2>\n<ul>\n<li>\n<p>resolve는 첫 성공 호출만 실행된다</p>\n<pre><code class=\"language-jsx\">let promise = new Promise(function(resolve, reject) {\n  resolve(1);//여기만 실행됨\n\n  setTimeout(() =&gt; resolve(2), 1000);\n});\n\npromise.then(alert);\n</code></pre>\n</li>\n<li>\n<p>Promise 는 마이크로태스크 큐에 들어가서 작업이 진행된다.</p>\n<ul>\n<li>마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행(FIFO, first-in-first-out).</li>\n<li>실행할 것이 아무것도 남아있지 않을 때만 마이크로태스크 큐에 있는 작업이 실행되기 시작</li>\n</ul>\n</li>\n<li>\n<p>setTimeout, Promise, script는 다음 우선 순위를 갖는다.</p>\n<ol>\n<li>script</li>\n<li>마이크로 테스크 Promise</li>\n<li>매크로 테스크 setTimeout</li>\n</ol>\n</li>\n</ul>\n<p>참고</p>\n<p><img src=\"https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif\" alt=\"https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif\"></p>\n<h3><a id=\"chaining\" class=\"anchor\" href=\"#chaining\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Chaining</h3>\n<pre><code class=\"language-jsx\">function loadScript(src){\n    return new Promise(resolve=&gt;{\n        setTimeout(()=&gt;{\n            console.log(src);\n            \n            resolve(src);\n        },1000);\n    })\n}\n\nloadScript('a')\n    .then(a =&gt; loadScript('b'))\n    .then(b =&gt; loadScript('c'))\n    .then(c=&gt;{\n        console.log(111);\n    });\n</code></pre>\n<h2><a id=\"thenable\" class=\"anchor\" href=\"#thenable\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Thenable</h2>\n<ul>\n<li>서드파티 라이브러리가 ‘프라미스와 호환 가능한’ 자체 객체를 구현할 수 있다는 점에서 나옴</li>\n<li>네이티브 프라미스와 호환 가능</li>\n<li>비동기 동작은 항상 프라미스를 반환하도록 하는 것이 좋다</li>\n</ul>\n<pre><code class=\"language-jsx\">class Thenable {\n    num;\n\n    constructor(num) {\n        this.num = num;\n    }\n\n    then(resolve,reject){\n        setTimeout(()=&gt;{\n            resolve(this.num+1);\n        },3000);\n    }\n}\n\nnew Promise(resolve =&gt; {\n    resolve(1);\n}).then(res=&gt;{\n    return new Thenable(res);\n}).then(res=&gt;{\n    console.log(res);//3초후 2출력\n    return new Thenable(res);\n}).then(res=&gt;{\n    console.log(res);//3초후 3출력\n    return new Thenable(res);\n});\n</code></pre>\n<h2><a id=\"module\" class=\"anchor\" href=\"#module\" aria-hidden=\"true\"><svg aria-hidden=\"true\" class=\"octicon octicon-link\" height=\"16\" version=\"1.1\" viewbox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module</h2>\n<ul>\n<li>모듈은 항상 use Strict로 실행된다.</li>\n<li>한번만 평가된다. import를 두번한다고 두번 실행되지 않는다.</li>\n<li>모듈은 지연실행(defer)된다. html이 모두 로드되고 난 이후 실행 된다.</li>\n<li>html이 모두 로드되기전에 실행하려면 async로 로드한다.</li>\n</ul>","metaData":{"title":"CORE-JS","category":"javascript","date":"2022-06-24","summary":"코어 자바스크립트","thumb":"/image/thumb.png"},"path":"CORE-JS","markdown":"\r\r\n# CORE JS\r\r\n\r\r\n## undefined와 null의 차이\r\r\n\r\r\nundefined는 변수를 선언하고 값을 할당하지 않은 상태이다.\r\r\n\r\r\nnull은 변수를 선언하고 빈 값을 할당한 상태이다.\r\r\n\r\r\nundefined는 전역 객체의 속성 중 하나이고 전역 스코프에서 변수이기도 하다.\r\r\n\r\r\nundefined는 예약어가 아니기 때문에 변수 이름으로 사용할 수 있다.\r\r\n\r\r\n아래의 경우 변수가 undefined를 반환한다.\r\r\n\r\r\n- 값을 할당하지 않은 변수\r\r\n- 메서드와 선언에서 변수가 할당받지 않은 경우\r\r\n- 함수가 값을 return 하지 않았을 때\r\r\n\r\r\n- null은 어떤 값이 의도적으로 비어 있음을 말한다. null은 해당 변수가 어떤 객체도 가리키고 있지 않다는 것을 의미한다.\r\r\n- null은 undefined 처럼 전역 객체의 속성 중 하나가 아니라 리터럴 값이다.\r\r\n- typeof null 은 object를 반환 하지만 하위 호환성을 유지하기위한 오류를 남겨둔 것이다. null은 object가 아니다.\r\r\n\r\r\n## 형 변환\r\r\n\r\r\n숫자형으로 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어난다.\r\r\n\r\r\n```jsx\r\r\nalert('6' / '2'); // 3을 반환한다. 자동 형변환 됨\r\r\nalert('hi' / 2); // Nan을 반환한다.\r\r\n```\r\r\n\r\r\n## 연산자의 우선순위\r\r\n\r\r\n17 단항 덧셈 +\r\r\n\r\r\n17 단항 부정 -\r\r\n\r\r\n16 지수 **\r\r\n\r\r\n15 곱셈 *\r\r\n\r\r\n15 나눗셈 /\r\r\n\r\r\n13 덧셈 +\r\r\n\r\r\n13 뺄셈 -\r\r\n\r\r\n3   할당 =\r\r\n\r\r\n## 복합연산\r\r\n\r\r\n복합연산은 오른쪽에서 왼쪽으로 진행된다.\r\r\n\r\r\n```jsx\r\r\nlet a,b,c;\r\r\n\r\r\na = b = c = 2 + 2;\r\r\n```\r\r\n\r\r\n## 쉼표 연산자\r\r\n\r\r\n, 는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다.\r\r\n\r\r\n## 문자열 비교 알고리즘\r\r\n\r\r\n1. 유니코드 순서로 비교한다 (유니코드 값으로 비교하면 a가 A보다 크다)\r\r\n2. 글자를 첫 글자부터 하나씩 비교해 나가면서 크기를 비교한다\r\r\n\r\r\n- 비교하려는 자료형이 다르면 숫자로 변환하여 비교한다\r\r\n\r\r\n## null과 0의 비교\r\r\n\r\r\n```jsx\r\r\nalert( null > 0 );  // (1) false\r\r\nalert( null == 0 ); // (2) false\r\r\nalert( null >= 0 ); // (3) true\r\r\n```\r\r\n\r\r\n- ==은 피연산자가 null일때 형변환을 하지 않는다.\r\r\n- ≥ ≤ < > 는 형변환을 하고 비교를 진행한다.\r\r\n\r\r\n```jsx\r\r\nconsole.log( undefined >= 0 ); //false\r\r\n```\r\r\n\r\r\n- undefined는 Nan으로 형변환 된다.\r\r\n\r\r\n### 위 상황을 피하는 방법\r\r\n\r\r\n- ===을 제외한 비교 연산자의 피 연산자에 undefined나 null이 오지 않도록 주의한다.\r\r\n- undefined나 null이 될 가능성이 있는 변수가 <,>,≤,≥의 피 연산자가 되지 않도록 주의한다.\r\r\n\r\r\n## OR의 반환 값\r\r\n\r\r\nOR가 참일 때 의 반환 값은 boolean이 아니라 결과 값 그 자체\r\r\n\r\r\n```jsx\r\r\nconst a = false;\r\r\nconst b = 10;\r\r\n\r\r\nconst c = a || b; // c = 10\r\r\n```\r\r\n\r\r\n## AND와 OR의 우선순위\r\r\n\r\r\n- AND가 OR 보다 우선순위가 더 높다\r\r\n    - a && b || c && d는 (a && b) || (c && d)와 동일하게 동작\r\r\n\r\r\n\r\r\n```jsx\r\r\nalert( null || 2 && 3 || 4 );\r\r\n\r\r\n// 3이 출력된다 &&가 || 보다 우선순위가 높다 \r\r\n// 2도 참이고 3도 참이기 때문에 2 && 3 은 3을 반환한다.\r\r\n\r\r\nif(-1) {\r\r\n    console.log(1); // 실행된다.\r\r\n}\r\r\n```\r\r\n\r\r\n## nullish 병합 연산자\r\r\n\r\r\n??는 =와 ? 보다는 먼저, 대부분의 연산자보다는 나중에 평가\r\r\n\r\r\n```jsx\r\r\na !== null && a !== undefined;\r\r\na ?? b;\r\r\n\r\r\nlet height = 0;\r\r\n\r\r\nalert(height || 100); // 100\r\r\nalert(height ?? 100); // 0\r\r\n```\r\r\n\r\r\n## 루프\r\r\n\r\r\n? 연산자 우측에 루프문 continue를 사용 할 수 없다\r\r\n\r\r\n```\r\r\n(i > 5) ? alert(i) : continue; // 여기에 continue를 사용하면 안 됩니다.\r\r\n```\r\r\n\r\r\n## 바벨(Babel)\r\r\n\r\r\n- 코드를 재작성해주는 트랜스파일러 프로그램\r\r\n- 실행하면 기존 코드가 구 표준을 준수하는 코드로 변경됨\r\r\n- 웹팩과 함께 사용하면 코드가 변경될 때 자동으로 트랜스파일러를 동작시킴\r\r\n\r\r\n## 계산된 프로퍼티\r\r\n\r\r\n```jsx\r\r\nconst a = 'hello';\r\r\n\r\r\nconst o = {\r\r\n\t[a] : 'world'\r\r\n}\r\r\n```\r\r\n\r\r\n## 객체의 정렬\r\r\n\r\r\n- 키 값이 숫자라면 키 순서로 자동 정렬 된다.\r\r\n- ‘1’ 은 숫자로 자동 형 변환된다.\r\r\n- 문자는 추가되는 순서로 들어간다.\r\r\n\r\r\n```jsx\r\r\nconst o2 = {\r\r\n    45:'test45',\r\r\n    1:'test1'\r\r\n};\r\r\n\r\r\n//결과 : { '1': 'test1', '45': 'test45' }\r\r\n```\r\r\n\r\r\n## Symbol\r\r\n\r\r\nSymbol은 유일한 식별자를 만들고 싶을 때 사용함\r\r\n\r\r\n### 특징\r\r\n\r\r\n- for in 으로 접근 할 수 없음\r\r\n- Object.properties로 출력 되지 않음\r\r\n- alert(Symbol(’test’))로 출력 되지 않음(문자열로 변환 안됨)\r\r\n\r\r\n### 전역심볼\r\r\n\r\r\n- Symbol.for(”id”) 없으면 만들어 쓰고 있으면 가저옴\r\r\n\r\r\n## ..\r\r\n\r\r\n.. 은 숫자에 래퍼 메소드를 사용할때 사용됨\r\r\n\r\r\n```jsx\r\r\n123.toString() // error .을 소수점으로 판단함\r\r\n123..toString() // ok\r\r\n```\r\r\n\r\r\n## isNan 과 isFinite\r\r\n\r\r\n- Nan은 자기 자신을 포함하여 그 어떤 값과도 같지 않다\r\r\n- isFinite는 문자열이 일반 숫자인지 검증하는 데 사용되곤 한다.\r\r\n\r\r\n```jsx\r\r\nalert( isNaN(NaN) ); // true\r\r\nalert( isNaN(\"str\") ); // true\r\r\n\r\r\nalert( NaN === NaN ); // false\r\r\n//자기 자신을 포함하여 그 어떤 값과도 같지 않다\r\r\nalert( Object.is(NaN,NaN )); // true\r\r\n```\r\r\n\r\r\n## 숫자 형변환 차이점 (+, parseInt, Number)\r\r\n\r\r\n```jsx\r\r\nalert( +\"100px\" ); // NaN\r\r\n\r\r\nalert( parseInt('100px') ); // 100\r\r\nalert( parseFloat('12.5em') ); // 12.5\r\r\n\r\r\nalert( parseInt('12.3') ); // 12, 정수 부분만 반환됩니다.\r\r\nalert( parseFloat('12.3.4') ); // 12.3, 두 번째 점에서 숫자 읽기를 멈춥니다.\r\r\n```\r\r\n\r\r\n## 태그드리터럴\r\r\n\r\r\n```jsx\r\r\nfunction myString(str,name,age){\r\r\n    return `${str.join('')} ${name} ${age}`;\r\r\n}\r\r\n\r\r\nconst name = '홍길동';\r\r\nconst age = 18;\r\r\n\r\r\nconst a = myString`hello world ${name} ${age}`;\r\r\n\r\r\nconsole.log(a); // hello world  홍길동 18\r\r\n```\r\r\n\r\r\n## for..in\r\r\n\r\r\n- 모든 프로퍼티를 순회하기 때문에 사용을 지양한다.\r\r\n- 객체와 함께 사용할 때 최적화 되어있다. 배열을 순회할 때 성능 저하가 있으므로 배열에서 사용을 지양한다.\r\r\n\r\r\n## 배열\r\r\n\r\r\n### 삭제\r\r\n\r\r\n- delete로 삭제했을때의 문제점\r\r\n\r\r\n    ```jsx\r\r\n    let arr = [\"I\", \"go\", \"home\"];\r\r\n    \r\r\n    delete arr[1]; // \"go\"를 삭제합니다.\r\r\n    \r\r\n    alert( arr[1] ); // undefined\r\r\n    \r\r\n    // delete를 써서 요소를 지우고 난 후 배열 --> arr = [\"I\",  , \"home\"];\r\r\n    alert( arr.length ); // 3\r\r\n    \r\r\n    //값은 삭제되지만 요소가 삭제되지 않는다.\r\r\n    ```\r\r\n\r\r\n\r\r\n### 교체\r\r\n\r\r\n```jsx\r\r\nlet arr = [\"I\", \"study\", \"JavaScript\", \"right\", \"now\"];\r\r\n\r\r\n// 처음(0) 세 개(3)의 요소를 지우고, 이 자리를 다른 요소로 대체합니다.\r\r\narr.splice(0, 3, \"Let's\", \"dance\");\r\r\n\r\r\nalert( arr ) // now [\"Let's\", \"dance\", \"right\", \"now\"]\r\r\n```\r\r\n\r\r\n### 추가\r\r\n\r\r\n```jsx\r\r\nlet arr = [\"I\", \"study\", \"JavaScript\"];\r\r\n\r\r\n// 인덱스 2부터\r\r\n// 0개의 요소를 삭제합니다.\r\r\n// 그 후, \"complex\"와 \"language\"를 추가합니다.\r\r\narr.splice(2, 0, \"complex\", \"language\");\r\r\n\r\r\nalert( arr ); // \"I\", \"study\", \"complex\", \"language\", \"JavaScript\"\r\r\n```\r\r\n\r\r\n### 정렬\r\r\n\r\r\n- sort는 문자열로 취급되어 정렬된다.\r\r\n- sort는 최적화된 퀵 정렬을 이용한다.\r\r\n- 숫자로 취급하기 위해서는 다음과 같이 정렬 함수를 넘겨준다.\r\r\n\r\r\n    ```jsx\r\r\n    const arr = [1,2,3,4,15];\r\r\n    arr.sort((a,b)=>a-b); // 오름차순\r\r\n    arr.sort((a,b)=>a+b); // 내림차순\r\r\n    ```\r\r\n\r\r\n- sort는 배열 자체를 변경하므로 다음과 같이 방어적 복사를 진행하는 것이 좋다\r\r\n\r\r\n    ```jsx\r\r\n    const arr = [1,2,15,4,6];\r\r\n    const sorted = [...arr].sort((a,b)=>a-b);\r\r\n    ```\r\r\n\r\r\n\r\r\n## iterable 객체\r\r\n\r\r\n- iterable은 메서드 Symbol.iterator가 구현된 객체이다.\r\r\n- array-like는 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체이다.\r\r\n- iterable과 array-like는 다르다.\r\r\n\r\r\n1. for..of가 시작되자마자 for..of는 Symbol.iterator를 호출합니다(Symbol.iterator가 없으면 에러가 발생합니다). Symbol.iterator는 반드시 이터레이터(iterator, 메서드 next가 있는 객체) 를 반환해야 합니다.\r\r\n2. 이후 for..of는 반환된 객체(이터레이터)만을 대상으로 동작합니다.\r\r\n3. for..of에 다음 값이 필요하면, for..of는 이터레이터의 next()메서드를 호출합니다.\r\r\n4. next()의 반환 값은 {done: Boolean, value: any}와 같은 형태이어야 합니다. done=true는 반복이 종료되었음을 의미합니다. done=false일땐 value에 다음 값이 저장됩니다.\r\r\n\r\r\n```jsx\r\r\nconsole.log(\"test\"[Symbol.iterator]); //[Function: [Symbol.iterator]]\r\r\nconsole.log(([][Symbol.iterator])); //[Function: values]\r\r\n```\r\r\n\r\r\n### 직접 구현해보기\r\r\n\r\r\n```jsx\r\r\nconst Range = (from, to) => {\r\r\n    return {\r\r\n        [Symbol.iterator](){\r\r\n            this.current = from;\r\r\n            return this;\r\r\n        },\r\r\n\r\r\n        next(){\r\r\n            if(this.current <= to){\r\r\n                return {done:false,value:this.current++};\r\r\n            }else{\r\r\n                return {done:true}\r\r\n            }\r\r\n        }\r\r\n    }\r\r\n};\r\r\n\r\r\nconsole.log(Range(1,10));\r\r\nconsole.log(Array.from(Range(1,10)));\r\r\n```\r\r\n\r\r\n### 문자열도 iterable이다\r\r\n\r\r\n```jsx\r\r\nArray.from(\"test\"); // ['t','e','s','t']\r\r\n```\r\r\n\r\r\n## 맵\r\r\n\r\r\nObject.entries() 객체를 맵으로 바꾸기\r\r\n\r\r\n```jsx\r\r\nlet obj = {\r\r\n  name: \"John\",\r\r\n  age: 30\r\r\n};\r\r\n\r\r\nlet map = new Map(Object.entries(obj));\r\r\n\r\r\nalert( map.get('name') ); // John\r\r\n```\r\r\n\r\r\n## 위크 맵,위크 셋\r\r\n\r\r\n가비지컬렉션이 메모리에서 자동으로 삭제 될 수 있도록 도와준다.\r\r\n\r\r\n```jsx\r\r\nlet john = { name: \"John\" };\r\r\n\r\r\nlet weakMap = new WeakMap();\r\r\nweakMap.set(john, \"...\");\r\r\n\r\r\njohn = null; // 참조를 덮어씀\r\r\n\r\r\n// john을 나타내는 객체는 이제 메모리에서 지워집니다!\r\r\n```\r\r\n\r\r\n## 구조분해할당\r\r\n\r\r\n- 할당 연산자 우측엔 모든 이터러블이 올 수 있다.\r\r\n- 할당 연산자의 좌측에는 어떤 것이든 올 수 있다\r\r\n\r\r\n    ```jsx\r\r\n    let user = {};\r\r\n    [user.name, user.surname] = \"Bora Lee\".split(' ');\r\r\n    \r\r\n    alert(user.name); // Bora\r\r\n    ```\r\r\n\r\r\n\r\r\n## JSON\r\r\n\r\r\n직렬화\r\r\n\r\r\n```jsx\r\r\nconst User = (name,age,date = new Date()) => {\r\r\n    return {\r\r\n        toJSON : () => {\r\r\n            return {name,age,date}\r\r\n        }\r\r\n    }\r\r\n}\r\r\n\r\r\nconst user = User('홍길동',15);\r\r\n\r\r\nconst jsonString = JSON.stringify(user);\r\r\n\r\r\nconst toObject = JSON.parse(jsonString,(key,value)=>{\r\r\n    if (key === 'date'){\r\r\n        return new Date(value);\r\r\n    }\r\r\n\r\r\n    return value;\r\r\n});\r\r\n\r\r\nconsole.log(toObject);\r\r\n```\r\r\n\r\r\n- 순환참조가 발생하면 JSON.parse를 사용할 수 없다. revival 함수에서 순환참조가 발생하는 property는 건너 뛰어야 한다.,\r\r\n\r\r\n## 클로저\r\r\n\r\r\n### Lexical Environment\r\r\n\r\r\n실행 중인 함수, 코드 블록, 스크립트 전체는 렉시컬 환경(Lexcial Environment)라 불리는 내부 숨김 연관 객체를 갖는다.\r\r\n\r\r\n렉시컬 환경 객체는 두 부분으로 구성된다. 렉시컬 횐경은 이론상의 객체이다.\r\r\n\r\r\n- 환경 레코드 (Environment Record) : 모든 지역 변수를 프로퍼티로 저장하고 있느 ㄴ객체.\r\r\n- 외부 렉시컬 환경(Outer) : 외부 코드와 연관된다.\r\r\n\r\r\n## 렉시컬 등록 순서\r\r\n\r\r\n1. 호이스팅한다\r\r\n2. 렉시컬 환경에 등록한다. (이때 함수는 위로 올라가고 즉시 실행 가능해진다. let, const로 선언한 변수는 렉시컬 환경에 등록되지만 let이 실행되기 전까지 참조가 불가능하다)\r\r\n3. 변수는 uninitialized로 올라가며 함수는 function으로 즉시 등록된다.\r\r\n\r\r\n### 변수의 렉시컬 환경\r\r\n\r\r\n```jsx\r\r\nlet test = 'hello';\r\r\n\r\r\n//이 경우에 렉시컬 환경이 하나만 존재한다. 전역 변수 이므로 outer는 null이다.\r\r\n```\r\r\n\r\r\n### 함수의 렉시컬 환경\r\r\n\r\r\n```jsx\r\r\nsay('hello');\r\r\n\r\r\nfunction say(name) {\r\r\n   console.log(`${name}`);\r\r\n}\r\r\n```\r\r\n\r\r\n함수는 렉시컬 환경에 등록되는 즉시 사용이 가능하다. 함수가 선언되기 전에 사용 가능한 것은 이러한 이유이다.\r\r\n\r\r\n## 비동기\r\r\n\r\r\n```jsx\r\r\nfunction block(time){\r\r\n    const endTime = Date.now() + time;\r\r\n\r\r\n    while(true){\r\r\n        const currentTime = Date.now();\r\r\n\r\r\n        if(currentTime > endTime){\r\r\n            break;\r\r\n        }\r\r\n    }\r\r\n\r\r\n    console.log('end');\r\r\n}\r\r\n\r\r\nfunction hello(){\r\r\n    console.log('hello');\r\r\n}\r\r\n\r\r\nsetTimeout(hello,2500);\r\r\n\r\r\nblock(3000);\r\r\n```\r\r\n\r\r\nhello 는 100ms 가 지난 후 바로 호출되지 않으며 block 메소드가 종료되고 난 이후 호출된다.\r\r\n\r\r\n## 기명 함수 표현식\r\r\n\r\r\n이름이 있는 함수 표현식\r\r\n\r\r\n```jsx\r\r\nlet sayHi = function func(who) {\r\r\n  if (who) {\r\r\n    alert(`Hello, ${who}`);\r\r\n  } else {\r\r\n    func(\"Guest\"); // func를 사용해서 자신을 호출합니다.\r\r\n  }\r\r\n};\r\r\n\r\r\nsayHi(); // Hello, Guest\r\r\n\r\r\n// 하지만 아래와 같이 func를 호출하는 건 불가능합니다.\r\r\nfunc(); // Error, func is not defined (기명 함수 표현식 밖에서는 그 이름에 접근할 수 없습니다.)\r\r\n```\r\r\n\r\r\n## new Function\r\r\n\r\r\n- eval을 사용하지 않고 문자열을 함수로 변경 할 수 있다.\r\r\n\r\r\n```\r\r\nlet str = ... 서버에서 동적으로 전달받은 문자열(코드 형태) ...\r\r\n\r\r\nlet func = new Function(str);\r\r\nfunc();\r\r\n```\r\r\n\r\r\n- new Function을 이용해 함수를 만들면 함수의 Environment 프로퍼티가 현재 렉시컬 환경이 아닌 전역 렉시컬 환경을 참조하게 된다.\r\r\n\r\r\n```jsx\r\r\nfunction getFunc() {\r\r\n  let value = \"test\";\r\r\n\r\r\n  let func = new Function('alert(value)');\r\r\n\r\r\n  return func;\r\r\n}\r\r\n\r\r\ngetFunc()(); // ReferenceError: value is not defined\r\r\n```\r\r\n\r\r\n## setTimeout,setInterval\r\r\n\r\r\n### 가비지 컬렉션과 setInterval·setTimeout\r\r\n\r\r\nsetInterval이나 setTimeout에 함수를 넘기면, 함수에 대한 내부 참조가 새롭게 만들어지고 이 참조 정보는 스케줄러에 저장됩니다. 따라서 해당 함수를 참조하는 것이 없어도 setInterval과 setTimeout에 넘긴 함수는 가비지 컬렉션의 대상이 되지 않습니다.\r\r\n\r\r\n```jsx\r\r\n// 스케줄러가 함수를 호출할 때까지 함수는 메모리에 유지됩니다.\r\r\nsetTimeout(function() {...}, 100);\r\r\n//setInterval의 경우는, clearInterval이 호출되기 전까지 함수에 대한 참조가 메모리에 유지됩니다.\r\r\n```\r\r\n\r\r\n그런데 이런 동작 방식에는 부작용이 하나 있습니다.\r\r\n\r\r\n외부 렉시컬 환경을 참조하는 함수가 있다고 가정해 봅시다. 이 함수가 메모리에 남아있는 동안엔 외부 변수 역시 메모리에 남아있기 마련입니다. 그런데 이렇게 되면 실제 함수가 차지했어야 하는 공간보다 더 많은 메모리 공간이 사용됩니다.\r\r\n\r\r\n이런 부작용을 방지하고 싶다면 스케줄링할 필요가 없어진 함수는 아무리 작더라도 취소하도록 합시다.\r\r\n\r\r\n### 브라우저 환경에서 실제 대기 시간은 0이 아닙니다.\r\r\n\r\r\n브라우저는 HTML5 표준에서 정한 중첩 타이머 실행 간격 관련 제약을 준수합니다. 해당 표준엔 \"다섯 번째 중첩 타이머 이후엔 대기 시간을 최소 4밀리초 이상으로 강제해야 한다.\"라는 제약이 명시되어있습니다.\r\r\n\r\r\n지연 없이 중첩 setTimeout을 5회 이상 호출하거나 지연 없는 setInterval에서 호출이 5회 이상 이뤄지면, 4밀리초 이상의 지연 간격이 강제로 더해집니다. 이는 브라우저에만 적용되는 사항이며, 하위 호환성을 위해 유지되고 있습니다.\r\r\n\r\r\n스케줄링 메서드를 사용할 땐 명시한 지연 간격이 보장되지 않을 수도 있다는 점에 유의해야 합니다.\r\r\n\r\r\n아래와 같은 상황에서 브라우저 내 타이머가 느려지면 지연 간격이 보장되지 않습니다.\r\r\n\r\r\n- CPU가 과부하 상태인 경우\r\r\n- 브라우저 탭이 백그라운드 모드인 경우\r\r\n- 노트북이 배터리에 의존해서 구동 중인 경우\r\r\n\r\r\n## Promise\r\r\n\r\r\n- resolve는 첫 성공 호출만 실행된다\r\r\n\r\r\n    ```jsx\r\r\n    let promise = new Promise(function(resolve, reject) {\r\r\n      resolve(1);//여기만 실행됨\r\r\n    \r\r\n      setTimeout(() => resolve(2), 1000);\r\r\n    });\r\r\n    \r\r\n    promise.then(alert);\r\r\n    ```\r\r\n\r\r\n- Promise 는 마이크로태스크 큐에 들어가서 작업이 진행된다.\r\r\n    - 마이크로태스크 큐는 먼저 들어온 작업을 먼저 실행(FIFO, first-in-first-out).\r\r\n    - 실행할 것이 아무것도 남아있지 않을 때만 마이크로태스크 큐에 있는 작업이 실행되기 시작\r\r\n- setTimeout, Promise, script는 다음 우선 순위를 갖는다.\r\r\n    1. script\r\r\n    2. 마이크로 테스크 Promise\r\r\n    3. 매크로 테스크 setTimeout\r\r\n\r\r\n참고\r\r\n\r\r\n![https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif](https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif)\r\r\n\r\r\n### Chaining\r\r\n\r\r\n```jsx\r\r\nfunction loadScript(src){\r\r\n    return new Promise(resolve=>{\r\r\n        setTimeout(()=>{\r\r\n            console.log(src);\r\r\n            \r\r\n            resolve(src);\r\r\n        },1000);\r\r\n    })\r\r\n}\r\r\n\r\r\nloadScript('a')\r\r\n    .then(a => loadScript('b'))\r\r\n    .then(b => loadScript('c'))\r\r\n    .then(c=>{\r\r\n        console.log(111);\r\r\n    });\r\r\n```\r\r\n\r\r\n## Thenable\r\r\n\r\r\n- 서드파티 라이브러리가 ‘프라미스와 호환 가능한’ 자체 객체를 구현할 수 있다는 점에서 나옴\r\r\n- 네이티브 프라미스와 호환 가능\r\r\n- 비동기 동작은 항상 프라미스를 반환하도록 하는 것이 좋다\r\r\n\r\r\n```jsx\r\r\nclass Thenable {\r\r\n    num;\r\r\n\r\r\n    constructor(num) {\r\r\n        this.num = num;\r\r\n    }\r\r\n\r\r\n    then(resolve,reject){\r\r\n        setTimeout(()=>{\r\r\n            resolve(this.num+1);\r\r\n        },3000);\r\r\n    }\r\r\n}\r\r\n\r\r\nnew Promise(resolve => {\r\r\n    resolve(1);\r\r\n}).then(res=>{\r\r\n    return new Thenable(res);\r\r\n}).then(res=>{\r\r\n    console.log(res);//3초후 2출력\r\r\n    return new Thenable(res);\r\r\n}).then(res=>{\r\r\n    console.log(res);//3초후 3출력\r\r\n    return new Thenable(res);\r\r\n});\r\r\n```\r\r\n\r\r\n## Module\r\r\n\r\r\n- 모듈은 항상 use Strict로 실행된다.\r\r\n- 한번만 평가된다. import를 두번한다고 두번 실행되지 않는다.\r\r\n- 모듈은 지연실행(defer)된다. html이 모두 로드되고 난 이후 실행 된다.\r\r\n- html이 모두 로드되기전에 실행하려면 async로 로드한다.\r\r\n","tocHtml":"<ul>\n<li><a href=\"#core-js\">CORE JS</a>\n<ul>\n<li><a href=\"#undefined%EC%99%80-null%EC%9D%98-%EC%B0%A8%EC%9D%B4\">undefined와 null의 차이</a></li>\n<li><a href=\"#%ED%98%95-%EB%B3%80%ED%99%98\">형 변환</a></li>\n</ul>\n</li>\n</ul>\n"}]